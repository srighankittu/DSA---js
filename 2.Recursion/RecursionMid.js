function ropeCut(n, a, b, c) {
  if (n == 0) return 0;
  if (n < 0) return -1;
  let res = Math.max(
    ropeCut(n - a, a, b, c),
    ropeCut(n - b, a, b, c),
    ropeCut(n - c, a, b, c)
  );

  if (res == -1) return -1;
  return res + 1;
}

// console.log(ropeCut(9, 2, 2, 1));
// n=23, a=11,b=9,c=12

function subSets(s, cur = "", i = 0) {
  if (i === s.length) {
    console.log(cur);
    return;
  }
  subSets(s, cur, i + 1);
  subSets(s, cur + s[i], i + 1);
}

// subSets("ABC");

function josephus(n, k) {
  if (n == 1) return 0;
  return (josephus(n - 1, k) + k) % n;
}

// console.log(josephus(5, 3));

function subSetSum(arr, size, res, curArr = []) {
  if (size == 0) {
    // console.log(res);
    return res == 0 ? 1 : 0;
  }
  return (
    subSetSum(arr, size - 1, res - arr[size - 1]) +
    subSetSum(arr, size - 1, res)
  );
}
// console.log(subSetSum([1, 2, 3], 3, 3));

// Intuition is to fix one position and then change other positions

function permuts(mainStr, itr = 0) {
  if (itr === mainStr.length) {
    console.log(mainStr);
    return;
  }
  for (let i = itr; i < mainStr.length; i++) {
    mainStr = swapStrIdx(mainStr, i, itr);
    permuts(mainStr, itr + 1);
    // mainStr = swapStrIdx(mainStr, i, itr);  This is not required for JS.
  }
}

function swapStrIdx(str, i, j) {
  if (i == j) return str;
  const temp = str.split("");
  [temp[i], temp[j]] = [temp[j], temp[i]];
  return temp.join("");
}

// permuts("ABC");

//Solve this question for -ve powers as well
function powerOfN(n, p) {
  if (p == 1) return n; // p==0 return 1
  return n * powerOfN(n, p - 1);
}

// console.log(powerOfN(4, 2));

function subSets(str, curStr = "", idx = 0, res = []) {
  if (idx == str.length) {
    res.push(curStr);

    return;
  }
  subSets(str, curStr, idx + 1, res);
  subSets(str, curStr + str[idx], idx + 1, res);
  return res;
}

// console.log(subSets("ABC"));

//Lucky number
//Lucky numbers are subset of integers. Process of arriving at lucky numbers is:
// Take the set of integers 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,……
// First, delete every second number, we get following reduced set.
// 1, 3, 5, 7, 9, 11, 13, 15, 17, 19,…………
// Now, delete every third number, we get
// 1, 3, 7, 9, 13, 15, 19,….….
// Continue this process indefinitely……
// Any number that does NOT get deleted due to above process is called “lucky”.

// You are given a number N, you need to tell whether the number is lucky or not. If the number is lucky return 1 otherwise 0.

function LuckyNum(num, counter = 2) {
  if (num < counter) return true;
  if (num % counter == 0) {
    return false;
  }

  return LuckyNum(num - Math.floor(num / counter), counter + 1);
}
// console.log(LuckyNum(15));

// Given a keypad as shown in the diagram, and an array arr[ ],
// your task is to list all possible words in any order which can be
//  generated by pressing numbers from array.

function keyPad(dits) {
  const map = {
    2: "abc",
    3: "def",
    4: "ghi",
    5: "jkl",
    6: "mno",
    7: "pqrs",
    8: "tuv",
    9: "wxyz",
  };

  let res = [];
  function backtrack(digits, index = 0, path = "") {
    if (index == digits.length) {
      res.push(path);
      return;
    }
    const currentDigit = digits[index];
    // console.log(map);
    const letters = map[currentDigit];

    for (let letter of letters) {
      backtrack(digits, index + 1, path + letter);
    }
    return res;
  }
  return backtrack(dits);
}

// console.log(keyPad("23"));

// Input : candidates = [2, 3, 5, 4] , target = 7
// Output : [ [2, 2, 3] , [3, 4] , [5, 2] ]
// Explanation :
// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
// 5 and 2 are candidates, and 5 + 2 = 7.
// 3 and 4 are candidates, and 3 + 4 = 7.
// There are total three combinations.

let sol = [];
function combinationSumI(nums, target, res = 0, curArr = [], start = 0) {
  if (res == target) {
    // console.log(curArr);
    sol.push([...curArr]);
    return;
  }
  if (res > target) return;

  for (let i = start; i < nums.length; i++) {
    curArr.push(nums[i]);
    combinationSumI(nums, target, res + nums[i], curArr, i);
    curArr.pop();
  }
  // return sol;
}
// console.log(combinationSumI([1, 2, 3], 3));
// console.log(sol);

//your code goes here
function combi(studs, tar, curSum = 0, res = [], start = 0) {
  if (curSum == tar) {
    console.log(res);
    sol.push(res);
    return;
  }
  if (curSum > tar) return;
  for (let i = start; i < studs.length; i++) {
    res.push(studs[i]);
    combi(studs, tar, curSum + studs[i], res, i);
    res.pop();
  }
  return sol;
}
// console.log(combi([1, 2, 3], 3));

// console.log(combinationSumII([1, 2, 2], 3));
function combinationSum3(k, n) {
  //your code goes here
  let res = [];
  const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  function cc(num, sum, curArr = [], idx = 0) {
    if (curArr.length == num && sum == 0) {
      // console.log(curArr);
      res.push([...curArr]);
      return;
    }
    if (sum < 0 || curArr.length > num) return;
    for (let i = idx; i < numbers.length; i++) {
      curArr.push(numbers[i]);
      cc(num, sum - numbers[i], curArr, i + 1);
      curArr.pop();
    }
  }
  cc(k, n);
  return res;
}

// console.log(combinationSum3(3, 9));
function strUpd(n) {
  let res = "";
  let seq = "1";
  for (let j = 0; j < n; j++) {
    res = "";
    let cnt = 1;
    for (let i = 1; i < seq.length; i++) {
      if (seq[i] == seq[i - 1]) {
        cnt += 1;
      } else {
        res = res + cnt.toString() + seq[i - 1];
        // console.log(res);
        cnt = 1;
      }
    }
    res = res + cnt.toString() + seq[seq.length - 1];
    console.log(res);
    seq = res;
  }
  return seq;
}

function strApd(obj1) {
  let str = "";
  Object.entries(obj1).forEach(([key, val]) => {
    str = str + key + val;
  });
  return str;
}

console.log(strUpd(4));
